Custom Actor
============

.. include:: /experimental.rst.inc

.. include:: /advanced-topic.rst.inc

The ``custom`` actor can be used if maximum control and flexibility is
required, as it allows you to write custom hooks (pieces of Python code)
that link schedule results to entity states. In fact, you could even
implement advanced types like :doc:`../thermostat/index` with this one.

While this actor is probably not for daily use, it gives you the power
you need when implementing something really fancy.

.. note::

   When you're extensively using the custom actor type for something
   that could be interesting to other people as well, please consider
   filing your idea as an issue on GitHub to maybe get it included in
   Schedy natively. Thank you!


Understanding the Custom Actor
------------------------------

The purpose of every actor type is to provide a mapping between values
generated by a schedule and states of entities. These two terms, **value**
and **state**, are crucial for understanding how the custom actor works.

A value returned by a schedule may in fact be any Python object, be it
a string, number, boolean or even a custom type. The work to be done by
an implementation of the custom actor type is then to execute the Home
Assistant services needed to reach the state you want a particular value
to stand for. This work has to be acomplished in the so-called ``send``
hook, which is just normal Python code in which you can, for example,
call services.

.. note::

   You need to realize that values and states are two different things
   your custom actor implementation needs to link to each other..

However, the same work has to be done in the other direction as well. It
needs to be possible to map a given entity state to the value that, when
returned from a schedule, would cause that state to be achieved. This
is handled by the ``state`` hook. It gets all state attributes of the
watched entity and must return the value this state is caused by.

These two hooks, the ``send`` and the ``state`` hook, are
executed similarly to the :doc:`expressions used in schedules
<../../schedules/expressions/index>`. Both simple expressions
(single-line) and whole statements (multi-line) are possible. When using
whole statements, the result has to be stored in the global ``result``
variable as usual.

Inside the hooks, the following variables are available for you to
work with:

* ``state`` or ``value``: The input depending on the type of hook.
* ``entity_id``: The actor's entity id.
* ``config``: The custom configuration dictionary as defined in the
  actor configuration.
* ``app``: The ``appdaemon.plugins.hass.hassapi.Hass`` object to be used
  for calling services etc.
* ``actor``: The ``CustomActor`` object. The only purpose I could imagine
  for using this object directly is for generating custom log messages,
  e.g. for debugging purposes. You could do:

  ::

      actor.log("I'm going to send the value {}."
                .format(repr(value)),
                level="DEBUG")


Configuration
-------------

.. include:: ../config.rst.inc
